//
//  ViewController.swift
//  hw3
//
//  Created by Evgen Patlay on 28.10.17.
//  Copyright © 2017 Evgen Patlay. All rights reserved.
//

import UIKit

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        let name = "Zhenya"
        let nameString="Евгений Петрович"

      /* Создать строку со своим именем. Написать метод который получает это имя и возвращает кол-во символов в строке с вашим именем. Возвращенное значение показать в консоль*/
        print(nameCount(word: name))

        /* Написать метод который принимает 2 слова, например имя и фамилию, возвращает юзернейм который имеет буквы нижнего регистра и разделяет имя и фамилию символом “_” */
        let value = userName(name: "Zhenya", surname: "Patlay")
        print(value)

        /* Создать строку с именем и своим отчеством. Создать метод который проверит его на окончание “ич/на”. Выводит “М” или “Ж” в зависимости от окончания. Также учитывать регистр букв, то есть ИЧ или Ич или На и тд.
         Подсказка: в классе написан метод который позволяет проверить на суффикс или префикс, найдите и используйте его */
        patronymic(nameString: nameString)

        let val = nameCount(word: name)
        print(val)

        // Создать массив со значениями типа Int. Выполнить удаление всех элементов массива.
        var array = [1, 2, 3, 4]
        print(array)
        array.removeAll()


        // Создать 2 массива со значениями типа Int. Сделать соединение данных массивов. Результат вывести в консоль
        let first = [1, 2, 3]
        let second = [4, 5, 6]
        let result = first + second
        print(result)

        //Создать массив с любыми значениями типа строка. Создать метод который будет принимать как аргумент массив. Метод должен выводить в консоль элементы массива (по одному в одной строке)
        let arr = ["one", "two", "three"]
        printArr(arr: arr)


        // Создать массив с любыми значениями типа строка. Создать метод который будет принимать как аргумент массив. Метод должен возвращать массив который состоит из первого и последнего элемента массива, который был параметром
        let newArr = firstLast(arr: arr)
        print(newArr)

        /* Задание6
         Создать словарь в котором ключ будет Строкой а значение Целым. Например ключ - имя, значение - возраст. Должно быть 3 элемента (3 пары).
         Создать метод который будет иметь 2 параметра: словарь (типа “Строка : Целое”) и ключ типа Строка. Данный метод должен удалить из полученного (как первый аргумент) словаря элемент ключ которого был передан (как второй аргумент).
         Например: передаваемый словарь будет такой:
         ["Max": 1, "Dasha": 2, "Sergey": 3]
         И если передать второй аргумент "Sergey", то метод должен удалить элемент из передаваемого массива с ключом "Sergey". */
        var ages = ["Ivan": 25, "Sergey": 26, "Max": 27]
        ages["Dima"] = 28 //Создать словарь в котором ключ будет Строкой а значение Целым. Например ключ - имя, значение - возраст.
        ages["Alex"] = 29  //Должно быть 3 элемента (3 пары).  Добавить в данный словарь еще 2 новых элемента.

        print(ages)
        let temp = agesDel(ages: ages, key: "Sergey")
        print(temp)

        /* Создать метод который будет принимать строку где слитно написано Ваши ИмяФамилия “TungFam" и возвращать строку,  где они будут разделены пробелом
         input = “TungFam”
         output = “Tung Fam"
         Сложность задачи в том, что имя может быть любое. Например:
         Введя “ArtemPigor” должно вернуть “Artem Pigor”
         Введя “AnnaSecure” должно вернуть “Anna Secure”
         Введя “BlaCar” должно вернуть “Bla Car”
         То есть алгоритм разбивает два слова которые начинаются на большую букву */

        let name1 = nameWithEscape(name: "TungFam")
        print(name1)

        /* Создать метод который принимает как аргумент строку. Метод выводит строку зеркально, например Ось -> ьсО, Привет -> тевирП. не используя reverse (сделать алгоритм самому посимвольно) */
        revers(value: "123456789")

        /*добавить запятые в строку как их расставляет калькулятор
         1234567 -> 1,234,567
         12345 -> 12,345
         (не использовать встроенный метод для применения формата) */
        format(value: "123456789")

        /*  проверить пароль на надежность от 1 до 5
         a) если пароль содержит числа +1
         b) символы верхнего регистра +1
         c) символы нижнего регистра +1
         d) спец символы +1
         e) если длина пароля 8 или более символов +1

         пример:
         123456 - 1 a)
         qwertyui - 1 c)
         12345qwerty - 2 a) c)
         32556reWDr - 3 a) b) c)*/

        password(value: "123asdG#")

        /* Collections Hard:
         Задание1
         Создать метод который принимает 2 аргумента: массив строк и просто строку. Метод возвращает true или false в зависимости есть ли данный элемент (тот второй аргумент, который строка) в массиве (тот первый аргумент, который массив строк).
         например массив
         let array = [“one”, “two”]
         и если передать в этот метод “one“ то должно вернуть true
         а если передать “three” то должно вернуть false*/
        print(collectionsHardOne(array: arr, word: "five"))

        /* Задание 2
         метод который выведет все ключи словаря
         метод который выведет все значения словаря */
        collectionHardTwo(dic: ages)

        /*
         Задание 3
         сортировка массива не встроенным методом по возрастанию + удалить дубликаты
         Например задается массив [3, 6, 1, 2, 2, 6, 13, 77, 36]
         Результат должен быть [1, 2, 3, 6, 13, 36, 77] */
        print(collectionsHardThree(array: [3,6,1,2,2,6,13,77,36]))

        /*
         Задание4
         Во ViewDidLoad создать словарь внутри которого будет 2 словаря (ключ - строка, значение - словарь). С любыми данными. Их мы будем передавать в метод, который напишем.
         Создать метод который будет принимать как параметры: словарь (такого типа как выше) и строку. Данный метод должен вернуть значение которое хранится внутри элемента ключ которого был передан как аргумент. */
        let addressBook = ["Ivan" : ["phone" : 0975546724, "age" : 25],
                           "Sergey" : ["phone" : 0672347654, "age" : 26],
                           "Max" : ["phone" : 0506734562, "age" : 27]]
        print(collectionHardFor(list: addressBook, name: "Ivan"))

    }

    /* Создать строку со своим именем. Написать метод который получает это имя и возвращает кол-во символов в строке с вашим именем. Возвращенное значение показать в консоль*/
    func nameCount(word: String) -> Int {
        let value = word.count
        return value
    }

    /* Написать метод который принимает 2 слова, например имя и фамилию, возвращает юзернейм который имеет буквы нижнего регистра и разделяет имя и фамилию символом “_” */
    func userName (name: String, surname: String) -> String {
        let userName = name + "_" + surname
        return userName.lowercased()
    }


    /* Создать строку с именем и своим отчеством. Создать метод который проверит его на окончание “ич/на”. Выводит “М” или “Ж” в зависимости от окончания. Также учитывать регистр букв, то есть ИЧ или Ич или На и тд.
     Подсказка: в классе написан метод который позволяет проверить на суффикс или префикс, найдите и используйте его */
    func patronymic(nameString: String)  {
        if nameString.lowercased().hasSuffix("ич") {
            print("M")
        }else if nameString.lowercased().hasSuffix("на") {
            print("Ж")
        }else {
            print("404")
        }
    }


    //Создать массив с любыми значениями типа строка. Создать метод который будет принимать как аргумент массив. Метод должен выводить в консоль элементы массива (по одному в одной строке)
    func printArr(arr:[String]) {
        for word in arr {
            print(word)
        }
    }


    // Создать массив с любыми значениями типа строка. Создать метод который будет принимать как аргумент массив. Метод должен возвращать массив который состоит из первого и последнего элемента массива, который был параметром
    func firstLast(arr:[String]) -> [String]{
        var result = [String]()
        result.insert(arr[0], at: 0)
        result.insert(arr[arr.count-1], at: 1)
        return result
    }

    /* Задание6
     Создать словарь в котором ключ будет Строкой а значение Целым. Например ключ - имя, значение - возраст. Должно быть 3 элемента (3 пары).
     Создать метод который будет иметь 2 параметра: словарь (типа “Строка : Целое”) и ключ типа Строка. Данный метод должен удалить из полученного (как первый аргумент) словаря элемент ключ которого был передан (как второй аргумент).
     Например: передаваемый словарь будет такой:
     ["Max": 1, "Dasha": 2, "Sergey": 3]
     И если передать второй аргумент "Sergey", то метод должен удалить элемент из передаваемого массива с ключом "Sergey". */
    func agesDel(ages:[String:Int], key: (String)) -> [String : Int] {
        var tempAges = ages
        for name in tempAges.keys {
            if (name == key) {
                tempAges[name] = nil
            }
        }
        return tempAges
    }

    /* Создать метод который будет принимать строку где слитно написано Ваши ИмяФамилия “TungFam" и возвращать строку,  где они будут разделены пробелом
     input = “TungFam”
     output = “Tung Fam"
     Сложность задачи в том, что имя может быть любое. Например:
     Введя “ArtemPigor” должно вернуть “Artem Pigor”
     Введя “AnnaSecure” должно вернуть “Anna Secure”
     Введя “BlaCar” должно вернуть “Bla Car”
     То есть алгоритм разбивает два слова которые начинаются на большую букву */
    func nameWithEscape(name:(String)) -> String {
        //
        var firstChar = true
        var newName=""
        for char in name {
            if (char<="z" && char>="a"){
                newName += String (char)
            }else if firstChar {
                newName += String (char)
                firstChar = false
            } else {
                newName = newName + " "
                newName += String (char)
            }

        }
        return newName
    }

    /* Создать метод который принимает как аргумент строку. Метод выводит строку зеркально, например Ось -> ьсО, Привет -> тевирП. не используя reverse (сделать алгоритм самому посимвольно) */
    func revers(value:(String)) {
        var temp = ""
        var temp1=""
        for char in value{
            temp1 = temp1 + String(char)
            temp1 += temp
            temp = temp1
            temp1=""
        }
        print(temp)
    }

    /*добавить запятые в строку как их расставляет калькулятор
     1234567 -> 1,234,567
     12345 -> 12,345
     (не использовать встроенный метод для применения формата) */
    func format(value:String)  {
        let first = value.count % 3
        var temp = ""
        var i=0
        for char in value {
            i+=1
            if ((i==first || (i-first)%3==0 ) && i != value.count){
                temp = temp + String(char) + ","
            }else{
                temp = temp + String(char)

            }
        }
        print(temp)
    }
    /*  проверить пароль на надежность от 1 до 5
     a) если пароль содержит числа +1
     b) символы верхнего регистра +1
     c) символы нижнего регистра +1
     d) спец символы +1
     e) если длина пароля 8 или более символов +1

     пример:
     123456 - 1 a)
     qwertyui - 1 c)
     12345qwerty - 2 a) c)
     32556reWDr - 3 a) b) c)*/
    func password(value:String)  {
        var number = 0
        var char = 0
        var bigChar = 0
        var spec = 0
        var count = 0
        if(value.count>7) { count += 1}

        for symbol in value {
            if (symbol >= "0" && symbol <= "9") {number = 1}
            if (symbol >= "a" && symbol <= "z") {char = 1}
            if (symbol >= "A" && symbol <= "Z") {bigChar = 1}
            if (symbol < "0" ) {spec = 1}
        }
        let result = number + char + bigChar + spec + count
        print(result)
    }
    /* Collections Hard:
     Задание1
     Создать метод который принимает 2 аргумента: массив строк и просто строку. Метод возвращает true или false в зависимости есть ли данный элемент (тот второй аргумент, который строка) в массиве (тот первый аргумент, который массив строк).
     например массив
     let array = [“one”, “two”]
     и если передать в этот метод “one“ то должно вернуть true
     а если передать “three” то должно вернуть false*/
    func collectionsHardOne(array:[String], word:String) -> Bool {
        var result = false
        for value in array {
            if value==word { result = true}

        }
        return result
    }

/* Задание 2
 метод который выведет все ключи словаря
 метод который выведет все значения словаря */
    func collectionHardTwo(dic:[String:Int]){
        for key in dic.keys {
            print(key)
        }
        for value in dic {
            print(value.value)
        }
    }


/*
 Задание 3
 сортировка массива не встроенным методом по возрастанию + удалить дубликаты
 Например задается массив [3, 6, 1, 2, 2, 6, 13, 77, 36]
 Результат должен быть [1, 2, 3, 6, 13, 36, 77] */

    func collectionsHardThree(array:[Int]) -> [Int] {
        var temp = array
        var count = array.count
        for _ in 0...count-1 {
            for j in 0...count-2 {
                if temp[j]>temp[j+1] {
                    let tempValue = temp[j]
                    temp[j] = temp[j+1]
                    temp[j+1] = tempValue

                }
            }
        }
        var i = 0
        while temp.count > i+1 {
            i += 1
            if temp[i] == temp[i+1] {
                temp.remove(at: i)
                count -= 1
            }
            i += 1
        }
        return temp
    }


/*
     Задание4
     Во ViewDidLoad создать словарь внутри которого будет 2 словаря (ключ - строка, значение - словарь). С любыми данными. Их мы будем передавать в метод, который напишем.
     Создать метод который будет принимать как параметры: словарь (такого типа как выше) и строку. Данный метод должен вернуть значение которое хранится внутри элемента ключ которого был передан как аргумент. */
    func collectionHardFor(list:[String : [String : Int]], name: String) -> [String : Int] {
        var result = ["error" : 0]
        for value in list.keys {
            if value == name {
                result = list[value]!
                return result
            }

        }
return result
    }














}

